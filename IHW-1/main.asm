.include "macroses/services.s"
.include "macroses/fill_array.s"
.include "macroses/print_array.s"
.include "additional.s"

.data
	array_A:	.space 40
	array_A_end:
	array_B: 	.space 40
	array_B_end:
    	
#	 Сформировать массив B только из тех элементов массива , которые
#	не совпадают с его первым и последним элементами.
.global main

.text
	main:
		print_str ("Введите количество элементов в массиве - ")
		# Работу с массивом А делаем через макросы передевая аргументы через параметры
		read_len_of_array_a0	# Считываем длину массива А
		la	s1 array_A	# s1 хранит указатель на начало массива А
		push(s1)		# сохранили на стеке потому что это s_i регистр
		mv 	s3 a0		# s3 хранит длину массива А
		push(s3)		# сохранили на стеке потому что это s_i регистр
		fill_array (s1, s3)	# Заполняем массив А элементами из консоли
		pop(s3)			# восстановли со стека потому что это s_i регистр
		pop(s1)			# восстановли со стека потому что это s_i регистр
		push(s1)			# сохранили на стеке потому что это s_i регистр
		push(s3)			# сохранили на стеке потому что это s_i регистр
		print_array (s1, s3, "\nМассив А получился - \n")
		pop(s3)			# восстановли со стека потому что это s_i регистр
		pop(s1)			# восстановли со стека потому что это s_i регистр
		
		
		# Работу с массивом В реализуем через макросы передевая через параметры, отображаемые
		# на стек

		la	s2 array_B
		# [Передача на стек]
		push (s3) # передаем на стек длину массива
		push (s1) # передаем на стек указатель на начало массива А
		push (s2) # передаем на стек указтель на начало массива В
		#  получается стек состоит из: [len(a) - ptr(a) - ptr(b)
		make_b_array
		mv 	s4 a1 # получили длину B массива
		print_array(s2, s4,"В итоге массив В имеет вот такие элементы - \n")
		exit
	   
        
        
	
